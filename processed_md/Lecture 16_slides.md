# Lecture 16_slides

## Page 1

Length Extension Attacks
• Length extension attack: Given H(x) and the length of x, but not x, an 
attacker can create H(x || m) for any m of the attacker’s choosing
• Length extension attack - Wikipedia
• SHA-256 (256-bit version of SHA-2) is vulnerable
• SHA-3 is not vulnerable


## Page 2

Merkle-Damgard Scheme
Merkle-Damgard Scheme in Cryptography 
h7ps://www.geeksforgeeks.org/computer-networks/merkle-damgard-scheme-in-cryptography/


## Page 3

Do hashes provide integrity?
• It depends on your threat model
• Scenario
• Alice and Bob want to communicate over an insecure channel
• David might tamper with messages
• Idea: Use cryptographic hashes
• Alice sends her message with a cryptographic hash over the channel
• Bob receives the message and computes a hash on the message
• Bob checks that the hash he computed matches the hash sent by Alice
• Threat model: David can modify the message and the hash
• No integrity!


## Page 4

Man-in-the-middle attack
Alice
M’
MD’
M
MD
M
MD
M’
MD’
Bob
David


## Page 5

Do hashes provide integrity? 
• It depends on your threat model
• If the aJacker can modify the hash, hashes don’t provide integrity
• Main issue: Hashes are unkeyed funcLons
• There is no secret key being used as input, so any aBacker can compute a 
hash on any value


## Page 6

Solutions
• A message digest created using a secret symmetric key is known as a 
Message Authentication Code (MAC), because it can provide 
assurance that the message has not been modified
• The sender can also generate a message digest and then sign the 
digest using the private key of an asymmetric key pair, forming a 
digital signature. The signature must then be verified by the receiver 
through comparing it with a locally generated digest


## Page 7

Hashes: Summary
• Map arbitrary large input to fixed-length output
• Output is deterministic
• Security properties
• One way: Given an output y, it is infeasible to find any input x such that H(x) = y.
• Second preimage resistant: Given an input x, it is infeasible to find another input x' ≠ 
x such that H(x) = H(x').
• Collision resistant: It is infeasible to find any pair of inputs x' ≠ x such that H(x) = 
H(x’).
• Randomized output
• Some hashes are vulnerable to length extension attacks
• Hashes don’t provide integrity (unless you can publish the hash securely)


## Page 8

Message Authentication Code


## Page 9

Message authentication code (MAC)
• generated by an algorithm that creates a small fixed-sized block
• depending on both message and some key
• not be reversible
• MACM = F(KAB, M)
• appended to message as a signature
• receiver performs same computation on message and checks it 
matches the MAC
• provides assurance that message is unaltered and comes from sender


## Page 10

MACs: Usage
• Alice wants to send M to Bob, but doesn’t want David to tamper with it
• Alice sends M and T = MAC(K, M) to Bob
• Bob receives M and T
• Bob computes MAC(K, M) and checks that it matches T
• If the MACs match, Bob is confident the message has not been 
tampered with (integrity)


## Page 11

MACs: Definition
• Two parts:
• KeyGen() → K: Generate a key K
• MAC(K, M) → T: Generate a tag T for the message M using key K
• Inputs: A secret key and an arbitrary-length message
• Output: A fixed-length tag on the message
• Properties
• Correctness: Determinism
• Note: Some more complicated MAC schemes have an additional Verify(K, M, T) function 
that don’t require determinism, but this is out of scope
• Efficiency: Computing a MAC should be efficient
• Security: existentially unforgeable under chosen plaintext attack


## Page 12

Randomized MAC (Non-Deterministic)


